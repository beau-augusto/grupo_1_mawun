var app = angular.module('ViDApp');
app.service('descriptionService', ['dataService',
                                  '$rootScope',
                                  '$uibModal',
  function(dataService,
           $rootScope,
           $uibModal) {

  this.dataService = dataService;

  this.transmuteDescriptions = function() {
    var that = this;
    dataService.descriptions = _.map(dataService.descriptions, function (desc, ii) {
      desc.index = ii;
      desc.id = ii;
      desc.startTime = desc.start_time;
      desc.previousStartTime = desc.startTime;
      delete desc.start_time;
      desc.endTime = desc.end_time;
      desc.previousEndTime = desc.endTime;
      delete desc.end_time;
      desc.originalData = desc.text;
      desc.extended = that.dataService.job.extended && desc.extended;
      desc.snippet = that.dataService.parseSnippet(desc);
      desc.snippetStatus = (desc.snippet && desc.snippet.id) ? 'complete' : 'error';
      desc.snipPlayerState = 'stopped';
      desc.extendedControlsAvailable = desc.extended;
      desc.dirty = false;
      return desc;
    });
    _.each(dataService.descriptions, function(desc) {that.evaluateViolations(desc)});
  }

  this.setExtendedControls = function(desc, extendedControlsAvailable) {
    desc.extendedControlsAvailable = extendedControlsAvailable;
    if (extendedControlsAvailable) {
      var proposedEnd = desc.startTime + desc.snippet.duration;
      // shrink to next boundary if the desc is going to be extended
      var nextBoundaryTime = this.findNextBoundaryTime(desc);
      var newEnd = _.min([desc.endTime, proposedEnd, nextBoundaryTime]);
      this.setEndTime(desc, newEnd);
    } else if (!extendedControlsAvailable && desc.snippet.duration) {
      // expand end time to snippet duration if the desc is not extended
      this.setEndTime(desc, desc.startTime + desc.snippet.duration)
    }
  }

  this.nudge = function(desc, direction) {
    var nudge = dataService.nudgeAmount * 1000;
    if (direction === 'forward') {
      if (desc.endTime >= dataService.transcript.duration - 100) { return }
      if (desc.endTime + nudge > dataService.transcript.duration - 100) {
        this.nudgeToEnd(desc)
      } else {
        this.nudgeForward(desc, nudge)
      }
    } else if (direction === 'back') {
      if (desc.startTime <= 0) { return }
      if (desc.startTime - nudge < 0) {
        this.nudgeToStart(desc)
      } else {
        this.nudgebackward(desc, nudge)
      }
    }
    dataService.sortDescriptions();
    dataService.reindexDescriptions();
  }

  this.nudgeToStart = function(desc) {
    duration = desc.endTime - desc.startTime
    this.setStartTime(desc, 0);
    this.setEndTime(desc, duration);
  }

  this.nudgeToEnd = function(desc) {
    duration = desc.endTime - desc.startTime
    this.setEndTime(desc, dataService.transcript.duration - 100);
    this.setStartTime(desc, ((dataService.transcript.duration - 100) - duration));
  }

  this.nudgeForward = function(desc, nudge) {
    this.setStartTime(desc, desc.startTime + nudge);
    this.setEndTime(desc, desc.endTime + nudge);
  }

  this.nudgebackward = function(desc, nudge) {
    this.setStartTime(desc, _.max([desc.startTime - nudge, 0]));
    this.setEndTime(desc, _.max([desc.endTime - nudge, 0]));
  }

  this.nudgeEndTime = function(desc, direction) {
    if (!dataService.job.extended && !desc.extended) { return }
    var nudge = dataService.nudgeAmount * 1000;
    var newEnd;
    if (direction === "forward"){
      newEnd = desc.snippet ? _.min([desc.endTime + nudge, desc.startTime + desc.snippet.duration]) : desc.endTime + nudge
      newEnd = _.min([dataService.transcript.duration, newEnd])
    } else if (direction === "back"){
      newEnd = _.max([desc.endTime - nudge, desc.startTime, 0])
    }

    this.setEndTime(desc, newEnd);
  }

  this.setStartTime = function(desc, time) {
    desc.previousStartTime = desc.startTime || time;
    desc.startTime = time;
    this.evaluateViolations(desc)
    this.handleDescTimeChange(desc);
  }

  this.setEndTime = function(desc, time) {
    desc.previousEndTime = desc.endTime || time;
    desc.endTime = time;
    this.computeAndSetExtended(desc);
    this.evaluateViolations(desc)
    this.handleDescTimeChange(desc);
  }

  this.computeAndSetExtended = function(desc) {
    if (desc.snippet.id) {
      // if snippet is not processing, calculate if the desc is extended or not
      var compareSnippet =  desc.extendedControlsAvailable && desc.snippet.text === desc.text;
      var shouldExtend = compareSnippet ? (desc.endTime - desc.startTime) != desc.snippet.duration : false;
      if (desc.extended != shouldExtend) { this.setExtended(desc, shouldExtend) };
    } else if (desc.snippetStatus == 'pending' && desc.extendedControlsAvailable) {
      // if snippet is processing, set extended based on the controls value
      this.setExtended(desc, desc.extendedControlsAvailable)
    }
  }

  this.setExtended = function(desc, shouldExtend) {
    if (dataService.job.extended) {
      desc.extended = shouldExtend;
      this.broadcastDescUpdate(desc);
    }
  }

  this.setText = function(desc, text) {
    desc.text = text;
    this.markIfDirty(desc);
  }

  this.handleDescTimeChange = function(desc) {
    this.broadcastDescUpdate(desc);
    this.markIfDirty(desc);
    return desc.dirty;
  }

  this.broadcastDescUpdate = function(desc) {
    return $rootScope.$broadcast('desc-update', desc);
  }

  this.markIfDirty = function(desc) {
    if ((desc.originalData !== desc.text) || (desc.endTime !== desc.previousEndTime) || (desc.startTime !== desc.previousStartTime) || (desc.snippet.id && desc.snippet.text != desc.originalData)) {
      desc.dirty = true;
    } else {
      desc.dirty = false;
    }
    return desc.dirty;
  }

  this.findDescription = function(time){
    return _.find(dataService.descriptions, function(desc) {
      return desc.startTime <= time && desc.endTime > time
    });
  }

  this.findDescriptionsInRange = function(time1, time2) {
    return _.filter(dataService.descriptions, function(desc) {
      var descStartsInRange = time1 <= desc.startTime && desc.startTime <= time2;
      var descCoversRange = desc.startTime <= time1 && time2 <= desc.endTime;
      var descEndsInRange = time1 < desc.endTime && desc.endTime <= time2;
      return (descStartsInRange || descCoversRange || descEndsInRange)
    });
  }

  this.findDescriptionById = function(descId) {
    return _.find(dataService.descriptions, function(desc) {
      return desc.id === descId;
    })
  }

  this.setCurrentIndex = function(index){
    this.currentDescriptionIndex = index;
  }

  this.currentDescription = function() {
    return dataService.descriptions[this.currentDescriptionIndex];
  }

  this.openDeleteDescriptionModal = function(deleteDescIndex){
    $uibModal.open({
      ariaLabelledBy: 'modal-title-bottom',
      ariaDescribedBy: 'modal-body-bottom',
      templateUrl: 'delete-description-modal.html',
      size: 'med',
      resolve: {
        deleteDescIndex: function() {
          return deleteDescIndex;
        },
      },
      controller: 'DeleteDescriptionModalInstanceCtrl',
      controllerAs: '$ctrl'
    });
  }

  this.deleteDescription = function(deleteDescIndex) {
    deleteDescIndex = deleteDescIndex || 0;
    var desc = dataService.descriptions[deleteDescIndex];
    dataService.descriptions.splice(deleteDescIndex, 1);
    $rootScope.$broadcast('desc-delete', desc);
    dataService.reindexDescriptions();
    this.currentDescriptionIndex = _.max([deleteDescIndex - 1, 0]);
  }

  this.setDurationEstimate = function(desc) {
    // do the estimated duration overlap logic, for now reset violations from snippet fitter
    desc.violations = [];
    var newEstimate;
    var descReg = new RegExp('^' + _.escapeRegExp(desc.text), 'i');
    var snipReg = new RegExp('^' + _.escapeRegExp(desc.snippet.text), 'i');
    if (desc.endTime != null && !_.isEmpty(desc.snippet) && (desc.text.match(snipReg) || desc.snippet.text.match(descReg))) {
      if (desc.text.match(snipReg)) {
        newEstimate = desc.startTime + desc.snippet.duration + this.estimateDuration(desc.text.replace(snipReg, ''));
      } else if (desc.snippet.text.match(descReg)) {
        newEstimate = desc.startTime + desc.snippet.duration - this.estimateDuration(desc.snippet.text.replace(descReg, ''));
      }
    } else {
      newEstimate = desc.startTime + this.estimateDuration(desc.text);
    }
    this.setEndTime(desc, newEstimate);
  }

  this.estimateDuration = function(text) {
    text = this.stripArpabet(text);
    var numSyl = (text.match(/[aieouy]+/g) || []).length;
    if (text.match(/\w/)) { numSyl = _.max([numSyl, 1]) };
    numSyl += (text.match(/\d/g) || []).length;
    numSyl += (text.match(/\w\.\w/g) || []).length;
    numSyl += (text.match(/,/g) || []).length;
    return numSyl * dataService.speakingRate;
  }

  this.stripArpabet = function(text) {
    return text.replace(/\[([^\]]+)\]\(?\/[^\/]+\/\)?([\.\,\!\?])?/g, "$1$2");
  }

  this.evaluateViolations = function(desc) {
    var violations = this.computeViolations(desc);
    desc.violations = violations;
  }

  this.findNextBoundaryTime = function(desc) {
    var gapEndTime, nextDescStart, endOfTranscript;

    endOfTranscript = dataService.transcript.duration;

    var gap = this.findContainingGap(desc);
    gapEndTime = gap ? gap.end_time : desc.startTime;

    if (desc.index !== dataService.descriptions.length - 1) {
      var nextDesc = dataService.descriptions[desc.index + 1]
      nextDescStart = nextDesc && nextDesc.startTime;
    };
    return _.min([nextDescStart, gapEndTime, endOfTranscript]);
  }

  this.computeViolations = function(desc) {
    // return [[desc1, violations1], [desc2, violations2]]
    var violations = [];
    var transcriptViolations = this.findTranscriptOverlapViolations(desc);
    var descViolations = this.findDescriptionOverlapViolations(desc);

    if (!_.isEmpty(transcriptViolations)) { violations.push(transcriptViolations) }
    if (!_.isEmpty(descViolations)) { violations.push(descViolations) }
    return _.flatten(violations);
  }

  this.findDescriptionOverlapViolations = function(desc){
    var that = this;
    // find desc index in dataService.descriptions (sorted by startTime and endTime) and find the descriptions before and after to compare
    var startDescriptions = _.sortBy(dataService.descriptions, function(searchDesc){return searchDesc.startTime;});
    var startDescsToCompare = this.findSurroundingDescriptions(desc, startDescriptions);

    var endDescriptions = _.sortBy(dataService.descriptions, function(searchDesc){return searchDesc.endTime;});
    var endDescsToCompare = this.findSurroundingDescriptions(desc, endDescriptions);

    var violations = _(startDescsToCompare.concat(endDescsToCompare))
      .uniqBy(function(searchDesc) {return searchDesc.id;})
      .reject(function(searchDesc) {return searchDesc.id === desc.id})
      .map(function(searchDesc) {return that.findDescriptionViolation(desc, searchDesc);})
      .filter(function(violation) {return violation.violationType === 'overlap';})
      .value();

    return violations;
  }

  this.findSurroundingDescriptions = function(desc, sortedList) {
    var totalCount = sortedList.length;
    var searchDescsToCompare = [];
    var descStartIndex = _.findIndex(sortedList, function(searchDesc){return searchDesc.id === desc.id;})
    if (descStartIndex === -1) {return [];}
    if (descStartIndex !== 0) {searchDescsToCompare.push(sortedList[descStartIndex - 1])};
    if (descStartIndex < totalCount - 1) { searchDescsToCompare.push(sortedList[descStartIndex + 1])};
    return searchDescsToCompare;
  }

  this.findDescriptionViolation = function(desc, searchDesc) {
    var violationData = {violationType: 'none', violationTarget: 'description'}
    if (searchDesc.id === desc.id) { return violationData; };
    var leftOverlap = desc.startTime < searchDesc.startTime && desc.endTime > searchDesc.startTime;
    var rightOverlap = desc.endTime > searchDesc.endTime && desc.startTime < searchDesc.endTime;
    var completeOverlap = desc.startTime > searchDesc.startTime && desc.endTime < searchDesc.endTime;

    if (leftOverlap || rightOverlap || completeOverlap) {
      violationData.violationType = 'overlap';
      violationData.overlappedDescId = searchDesc.id;
    }

    return violationData;
  }

  this.findTranscriptOverlapViolations = function(desc){
    var violations = [];
    var violationData = {violationType: 'none', violationTarget: 'gap'};
    if (dataService.transcriptGaps.length < 1) {
      return [{violationType: 'overlap', violationTarget: 'gap'}];
    };

    var startDiffSet = this.findClosestGap(desc.startTime, _.map(dataService.transcriptGaps, function(gap){return gap.start_time}));
    var closestGapByStart = dataService.transcriptGaps[startDiffSet.index];

    var endDiffSet = this.findClosestGap(desc.endTime, _.map(dataService.transcriptGapsEndSorted, function(gap){return gap.end_time}));
    var closestGapByEnd =  dataService.transcriptGapsEndSorted[endDiffSet.index];

    var descInGapByStart = this.descInsideGap(desc, closestGapByStart);
    var descInGapByEnd = this.descInsideGap(desc, closestGapByEnd);

    if (!(descInGapByStart || descInGapByEnd)) {
      violationData.violationType = 'overlap';
      violations.push(violationData);
    }
    return violations;
  }

  this.descInsideGap = function(desc, gap) {
    // check if gap is entirely enclosed in the gap
    var descInsideGap = false;
    if (desc == null || gap == null) { return violationData }
    var startInGap = gap.start_time <= desc.startTime && desc.startTime <= gap.end_time;
    var endInGap = gap.start_time <= desc.endTime && desc.endTime <= gap.end_time;
    if (startInGap && endInGap) {
      descInsideGap = true;
    }
    return descInsideGap;
  }

  this.findContainingGap = function(desc) {
    var gaps = _(this.dataService.transcriptGaps)
    .sortBy(function(gap){return gap.start_time})
    .filter(function(gap){return gap.start_time <= desc.startTime && desc.startTime <= gap.end_time})
    .value();

    return _.first(gaps);
  }

  this.findClosestGap = function(time, sortedGapTimes) {
    var diffSets = _.map(sortedGapTimes, function(gapTime, ii){
      var diff = Math.abs(gapTime - time);
      return {difference: diff, index: ii};
    });
    var diffSet = _.minBy(diffSets, function(diffSet) {
      return diffSet.difference;
    });
    return diffSet;
  }

}]);
